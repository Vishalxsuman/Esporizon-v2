import{c as G,h as y,f as U,T as V,u as w,d as m,i as F,q as O,w as x,o as $,l as H,g as L,a as J,b as Y}from"./firebase-CrKjQ57N.js";class X{matchesCollection=G(Y,"matches");async createMatch(r,t,n,e){try{const s=this.generateInviteCode(),i=new Date;i.setMinutes(i.getMinutes()+30);const a=[{userId:t,userName:n,userAvatar:e,joinedAt:new Date().toISOString(),coinsLocked:r.entryFee,role:"creator",isBot:!1}];r.gameId==="chess"&&r.withBots&&a.push({userId:"bot-chess-engine",userName:"Chess Engine (Bot)",userAvatar:"https://api.dicebear.com/7.x/bottts/svg?seed=chess",joinedAt:new Date().toISOString(),coinsLocked:0,role:"participant",isBot:!0});let d=null;r.gameId==="chess"?d={fen:"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",turn:"white",moves:[],lastMove:null,createdAt:new Date().toISOString()}:r.gameId==="card29"&&(d={deck:[],hands:{},currentTrick:[],tricks:{},trumpSuit:null,round:1,scores:{},gamePoints:{team1:0,team2:0},phase:"bidding",turnStartedAt:y(),turnDuration:30,dealerIndex:0,currentBidder:3%4,currentPlayer:3%4,bids:{},highestBid:null,bidWinner:null,isDoubled:!1,isRedoubled:!1,bainPhase:"none",singleHandMode:!1,passedPlayers:[],lastTrickCards:[],createdAt:new Date().toISOString()});const l={gameId:r.gameId,gameName:r.gameId==="chess"?"Chess":"29 Card Game",mode:r.mode,visibility:r.visibility,entryFee:r.entryFee,prizePool:r.entryFee*r.maxPlayers,platformFee:10,platformFeeAmount:r.entryFee*r.maxPlayers*.1,winnerPrize:r.entryFee*r.maxPlayers*.9,timeControl:r.timeControl||600,creatorId:t,creatorName:n,creatorAvatar:e,players:a,maxPlayers:r.maxPlayers,status:r.gameId==="chess"&&r.withBots?"locked":"waiting",inviteCode:s,withBots:r.withBots,gameState:d,createdAt:new Date().toISOString(),expiresAt:i.toISOString(),...r.gameId==="chess"&&r.withBots?{startsAt:new Date().toISOString()}:{}},u=await U(this.matchesCollection,{...l,createdAt:y(),expiresAt:V.fromDate(i)});return{...l,id:u.id}}catch(s){throw console.error("Error creating match:",s),new Error("Failed to create match")}}async joinRoom(r,t){try{const n=await this.getMatchByInviteCode(r);if(!n)throw new Error("Room not found");return n.entryFee>0&&t.id.startsWith("guest_"),await this.joinMatch({matchId:n.id,userId:t.id,userName:t.name,userAvatar:t.avatar})}catch(n){throw console.error("Error joining room:",n),n}}async makeBid29(r,t,n,e,s){const i={...e.bids};let a=e.highestBid,d=e.phase,l=e.bidWinner,u=e.currentPlayer,f=e.bainPhase,c=e.currentBidder;const p=e.passedPlayers||[];if(p.includes(t))throw new Error("Player has already passed!");if(n==="pass"){if(i[t]=0,p.includes(t)||p.push(t),a&&t===a.playerId){let o=-1,P=null;s.forEach(B=>{const T=i[B.userId]||0;T>o?(o=T,P=B.userId):T===o&&o>0&&(P=B.userId)}),o>0?a={playerId:P,amount:o}:a=null}}else{if(n<16)throw new Error("Minimum bid is 16");if(n>28)throw new Error("Maximum bid is 28");if(a&&n<a.amount)throw new Error(`Bid must be at least ${a.amount}`);if(a&&n===a.amount){const o=a.playerId;console.log(`[MatchService] ${t} matched ${o} at ${n}`),c=s.findIndex(B=>B.userId===o),i[t]=n,await w(m(this.matchesCollection,r),{gameState:{...e,bids:i,currentBidder:c,passedPlayers:p,turnStartedAt:y()}});return}if(i[t]=n,a={playerId:t,amount:n},n===28){d="playing",l=t,u=s.findIndex(o=>o.userId===t),f="double_chance",await w(m(this.matchesCollection,r),{gameState:{...e,bids:i,highestBid:a,phase:d,bidWinner:l,currentPlayer:u,currentBidder:c,bainPhase:f,turnStartedAt:y()}});return}}const C=s.filter(o=>i[o.userId]!==0);if(C.length<=1&&a)d="playing",l=a.playerId,u=s.findIndex(o=>o.userId===a?.playerId),f="double_chance";else if(C.length===0&&Object.keys(i).length>=s.length){d="playing";const o=e.dealerIndex||0;l=s[o].userId,u=o,a={playerId:s[o].userId,amount:16},f="double_chance"}else{let o=c,P=0;do o=(o+3)%s.length,P++;while((i[s[o].userId]===0||p.includes(s[o].userId))&&P<s.length);c=o}await w(m(this.matchesCollection,r),{gameState:{...e,bids:i,highestBid:a,phase:d,bidWinner:l,currentPlayer:u,currentBidder:c,bainPhase:f,passedPlayers:p,turnStartedAt:y()}})}async joinMatch(r){try{const t=m(this.matchesCollection,r.matchId),n=await F(t);if(!n.exists())throw new Error("Match not found");const e={id:n.id,...n.data()};if(e.status!=="waiting")throw new Error("Match is no longer accepting players");if(e.players.length>=e.maxPlayers)throw new Error("Match is full");if(e.players.some(f=>f.userId===r.userId))throw new Error("Already joined this match");const s={userId:r.userId,userName:r.userName,userAvatar:r.userAvatar,joinedAt:new Date().toISOString(),coinsLocked:e.entryFee,role:"participant"},i=[...e.players,s],a=e.entryFee*i.length,d=a*(e.platformFee/100),l=a-d,u=i.length===e.maxPlayers?"locked":"waiting";return await w(t,{players:i,prizePool:a,platformFeeAmount:d,winnerPrize:l,status:u,...u==="locked"&&{startsAt:y()}}),{...e,players:i,prizePool:a,platformFeeAmount:d,winnerPrize:l,status:u,...u==="locked"&&{startsAt:new Date().toISOString()}}}catch(t){throw console.error("Error joining match:",t),t instanceof Error?t:new Error("Failed to join match")}}async getMatch(r){try{const t=await F(m(this.matchesCollection,r));return t.exists()?{id:t.id,...t.data()}:null}catch(t){return console.error("Error getting match:",t),null}}async getPublicLobbies(r){try{let t=O(this.matchesCollection,x("visibility","==","public"),x("status","==","waiting"),$("createdAt","desc"),H(20));return r&&(t=O(this.matchesCollection,x("visibility","==","public"),x("status","==","waiting"),x("gameId","==",r),$("createdAt","desc"),H(20))),(await L(t)).docs.map(e=>({id:e.id,...e.data()}))}catch(t){return console.error("Error getting public lobbies:",t),[]}}listenToMatch(r,t){const n=m(this.matchesCollection,r);return J(n,e=>{if(!e.exists()){t(null);return}t({id:e.id,...e.data()})},e=>{console.error("Error listening to match:",e),t(null)})}async submitResult(r){try{const t=m(this.matchesCollection,r.matchId);await w(t,{status:"completed",winnerId:r.winnerId,winnerName:r.winnerName,completedAt:y()})}catch(t){throw console.error("Error submitting result:",t),new Error("Failed to submit match result")}}async cancelMatch(r,t){try{const n=await this.getMatch(r);if(!n)throw new Error("Match not found");if(n.creatorId!==t)throw new Error("Only creator can cancel");if(n.status!=="waiting")throw new Error("Cannot cancel started match");const e=m(this.matchesCollection,r);await w(e,{status:"cancelled"})}catch(n){throw console.error("Error cancelling match:",n),n instanceof Error?n:new Error("Failed to cancel match")}}async getUserMatches(r){try{const t=O(this.matchesCollection,x("status","in",["waiting","locked","in_progress"]),$("createdAt","desc"));return(await L(t)).docs.map(s=>({id:s.id,...s.data()})).filter(s=>s.players.some(i=>i.userId===r))}catch(t){return console.error("Error getting user matches:",t),[]}}async getMatchByInviteCode(r){try{const t=O(this.matchesCollection,x("inviteCode","==",r.toUpperCase()),x("status","in",["waiting","locked"]),H(1)),n=await L(t);return n.empty?null:{id:n.docs[0].id,...n.docs[0].data()}}catch(t){return console.error("Error getting match by code:",t),null}}generateInviteCode(){return Math.random().toString(36).substring(2,8).toUpperCase()}async addBotToMatch(r){try{const t=m(this.matchesCollection,r),n=await F(t);if(!n.exists())throw new Error("Match not found");const e=n.data();if(e.players.length>=e.maxPlayers)throw new Error("Match is full");const s=e.players.filter(l=>l.isBot).length+1,i={userId:`bot-${Date.now()}`,userName:`Bot Player ${s}`,userAvatar:`https://api.dicebear.com/7.x/bottts/svg?seed=${Date.now()}`,joinedAt:new Date().toISOString(),coinsLocked:0,role:"participant",isBot:!0},a=[...e.players,i],d=a.length===e.maxPlayers?"locked":e.status;await w(t,{players:a,status:d,...d==="locked"&&{startsAt:y()}})}catch(t){throw console.error("Error adding bot:",t),new Error("Failed to add bot")}}async removeBotFromMatch(r,t){try{const n=m(this.matchesCollection,r),e=await F(n);if(!e.exists())throw new Error("Match not found");const s=e.data(),i=s.players.filter(d=>d.userId!==t),a=i.length<s.maxPlayers?"waiting":s.status;await w(n,{players:i,status:a})}catch(n){throw console.error("Error removing bot:",n),new Error("Failed to remove bot")}}async playCard29(r,t,n,e,s){const i=s.findIndex(h=>h.userId===t);if(e.currentPlayer!==i){console.warn(`[playCard29] ${t} tried to play out of turn. Current: ${e.currentPlayer}`);return}if(e.currentTrick.some(h=>h.playerId===t)){console.warn(`[playCard29] ${t} already played in this trick.`);return}if(e.currentTrick&&e.currentTrick.length>0){const h=e.currentTrick[0].card.suit;if(e.hands[t].some(b=>b.suit===h)&&n.suit!==h)throw new Error("Must follow suit!")}const a={...e.hands};a[t]=a[t].filter(h=>h.suit!==n.suit||h.rank!==n.rank);const d={playerId:t,card:n,playerName:s.find(h=>h.userId===t)?.userName||"Player"},l=[...e.currentTrick,d],u=[...e.lastTrickCards||[],d].slice(-4);let f=(e.currentPlayer-1+s.length)%s.length,c=e.tricks,p={...e.scores},C=l,o=e.round,P=e.trumpSuit,B=e.phase;if(l.length===s.length){const h=this.determineTrickWinner(l,e.trumpRevealed?P:null,e);await w(m(this.matchesCollection,r),{"gameState.hands":a,"gameState.currentTrick":l,"gameState.lastTrickCards":u,"gameState.lastMoveTime":new Date().toISOString(),"gameState.lastWinnerId":h}),await new Promise(b=>setTimeout(b,2e3));let _=l.reduce((b,E)=>b+this.getCardValue(E.card.rank),0);p[h]=(p[h]||0)+_;const q=Object.keys(c).length;if(c={...c,[q]:l},C=[],f=s.findIndex(b=>b.userId===h),e.singleHandMode){const E=1*(e.isRedoubled?4:e.isDoubled?2:1),v=s.findIndex(S=>S.userId===e.bidWinner)%2,M=s.findIndex(S=>S.userId===h)%2,W=v===M?E:-E,g=e.gamePoints?{...e.gamePoints}:{team1:0,team2:0};v===0?g.team1=(g.team1||0)+W:g.team2=(g.team2||0)+W,await w(m(this.matchesCollection,r),{status:"completed",winnerId:h,"gameState.gamePoints":g,"gameState.phase":"completed"});return}if(Object.keys(c).length===8){const b=[s[0].userId,s[2].userId],E=[s[1].userId,s[3].userId],v=b.reduce((k,N)=>k+(p[N]||0),0),M=E.reduce((k,N)=>k+(p[N]||0),0),K=(e.highestBid?.amount||16)+(e.bidAdjustment||0),W=e.bidWinner,g=b.includes(W)?1:2,j=(g===1?v:M)>=K;let A=1*(e.isRedoubled?4:e.isDoubled?2:1);const R=!e.trumpRevealed;R&&(A=0);const I=e.gamePoints?{...e.gamePoints}:{team1:0,team2:0};R||(j?g===1?I.team1=(I.team1||0)+A:I.team2=(I.team2||0)+A:g===1?I.team1=(I.team1||0)-A:I.team2=(I.team2||0)-A);const Q=I.team1||0,z=I.team2||0;if(Math.abs(Q)>=6||Math.abs(z)>=6){const k=Math.abs(Q)>=6?1:2;e.setWinner={team:k},e.showSetPopup=!0}else{const k=j?g:g===1?2:1;e.roundWinner={team:R?0:k,points:k===1?v:M,bidWon:j,isDraw:R},e.showRoundPopup=!0}e.gamePoints=I}}const T={...e,hands:a,currentTrick:C,tricks:c,currentPlayer:f,scores:p,round:o,phase:B,trumpSuit:P,lastTrickCards:u,turnStartedAt:y(),lastMoveTime:new Date().toISOString()};await w(m(this.matchesCollection,r),{gameState:T})}async selectTrump29(r,t,n,e,s){if(e.bidWinner!==t)throw new Error("Only the bid winner can select trump");const i={...e.hands},a=e.remainingDeck||[];if(!e.secondDealComplete&&a.length>=16){const u=((e.dealerIndex||0)+3)%4;s.forEach((f,c)=>{const p=(u-c+4)%4,C=s[p],o=a.slice(c*4,(c+1)*4);i[C.userId]=[...i[C.userId]||[],...o]})}const d={...e,trumpSuit:n,hands:i,secondDealComplete:!0,remainingDeck:[],turnStartedAt:y(),lastMoveTime:new Date().toISOString()};await w(m(this.matchesCollection,r),{gameState:d})}async revealTrump29(r,t){if(!t.trumpSuit)return;const n={...t,trumpRevealed:!0,turnStartedAt:y(),lastMoveTime:new Date().toISOString()};await w(m(this.matchesCollection,r),{gameState:n})}async declarePair29(r,t,n,e){if(!n.trumpRevealed||!n.trumpSuit)throw new Error("Trump must be revealed first");const s=n.hands[t]||[],i=s.some(c=>c.suit===n.trumpSuit&&c.rank==="K"),a=s.some(c=>c.suit===n.trumpSuit&&c.rank==="Q");if(!i||!a)throw new Error("You don't have the Pair (K & Q of Trump)");const d=e.findIndex(c=>c.userId===n.bidWinner)%2,l=e.findIndex(c=>c.userId===t)%2,u=d===l?-4:4,f={...n,bidAdjustment:(n.bidAdjustment||0)+u,pairDeclaredBy:t,turnStartedAt:y()};await w(m(this.matchesCollection,r),{gameState:f})}async dismissRoundPopup(r,t){const n=((t.dealerIndex||0)+3)%4,e=(n+3)%4,s={...t,round:(t.round||1)+1,dealerIndex:n,currentBidder:e,currentPlayer:e,currentTrick:[],tricks:{},scores:{},trumpSuit:null,trumpRevealed:!1,highestBid:null,bidWinner:null,bids:{},passedPlayers:[],secondDealComplete:!1,phase:"bidding",hands:{},roundWinner:null,showRoundPopup:!1,bidAdjustment:0,pairDeclaredBy:null,pairShown:!1,remainingDeck:[],lastTrickCards:[],turnStartedAt:y()};await w(m(this.matchesCollection,r),{gameState:s})}async dismissSetPopup(r,t){const n={...t,round:1,gamePoints:{team1:0,team2:0},currentTrick:[],tricks:{},scores:{},trumpSuit:null,trumpRevealed:!1,highestBid:null,bidWinner:null,bids:{},passedPlayers:[],secondDealComplete:!1,phase:"bidding",hands:{},roundWinner:null,showRoundPopup:!1,setWinner:null,showSetPopup:!1,bidAdjustment:0,pairDeclaredBy:null,remainingDeck:[],turnStartedAt:y(),currentBidder:0,currentPlayer:0};await w(m(this.matchesCollection,r),{gameState:n})}determineTrickWinner(r,t,n){const e={J:8,9:7,A:6,10:5,K:4,Q:3,8:2,7:1};if(n?.singleHandMode){let i=r[0];return r.forEach(a=>{e[a.card.rank]>e[i.card.rank]&&(i=a)}),i.playerId}let s=r[0];return r.forEach(i=>{(i.card.suit===t&&s.card.suit!==t||i.card.suit===s.card.suit&&e[i.card.rank]>e[s.card.rank])&&(s=i)}),s.playerId}getCardValue(r){return{J:3,9:2,A:1,10:1,K:0,Q:0,8:0,7:0}[r]||0}}const re=new X,Z=2.5,ne=D=>D*Z,se=D=>`${D.toLocaleString()} EC`;export{se as f,ne as i,re as m};
