import{a as $,g as G,p as y,m as U,r as V,d as w,e as m,t as S,q as F,w as x,o as N,l as H,b as q,f as J}from"./index-BI1Zh8jC.js";class Y{matchesCollection=$(G(),"matches");async createMatch(n,t,r,e){try{const s=this.generateInviteCode(),i=new Date;i.setMinutes(i.getMinutes()+30);const a=[{userId:t,userName:r,userAvatar:e,joinedAt:new Date().toISOString(),coinsLocked:n.entryFee,role:"creator",isBot:!1}];n.gameId==="chess"&&n.withBots&&a.push({userId:"bot-chess-engine",userName:"Chess Engine (Bot)",userAvatar:"https://api.dicebear.com/7.x/bottts/svg?seed=chess",joinedAt:new Date().toISOString(),coinsLocked:0,role:"participant",isBot:!0});let d=null;n.gameId==="chess"?d={fen:"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",turn:"white",moves:[],lastMove:null,createdAt:new Date().toISOString()}:n.gameId==="card29"&&(d={deck:[],hands:{},currentTrick:[],tricks:{},trumpSuit:null,round:1,scores:{},gamePoints:{team1:0,team2:0},phase:"bidding",turnStartedAt:y(),turnDuration:30,dealerIndex:0,currentBidder:3%4,currentPlayer:3%4,bids:{},highestBid:null,bidWinner:null,isDoubled:!1,isRedoubled:!1,bainPhase:"none",singleHandMode:!1,passedPlayers:[],lastTrickCards:[],createdAt:new Date().toISOString()});const l={gameId:n.gameId,gameName:n.gameId==="chess"?"Chess":"29 Card Game",mode:n.mode,visibility:n.visibility,entryFee:n.entryFee,prizePool:n.entryFee*n.maxPlayers,platformFee:10,platformFeeAmount:n.entryFee*n.maxPlayers*.1,winnerPrize:n.entryFee*n.maxPlayers*.9,timeControl:n.timeControl||600,creatorId:t,creatorName:r,creatorAvatar:e,players:a,maxPlayers:n.maxPlayers,status:n.gameId==="chess"&&n.withBots?"locked":"waiting",inviteCode:s,withBots:n.withBots,gameState:d,createdAt:new Date().toISOString(),expiresAt:i.toISOString(),...n.gameId==="chess"&&n.withBots?{startsAt:new Date().toISOString()}:{}},u=await U(this.matchesCollection,{...l,createdAt:y(),expiresAt:V.fromDate(i)});return{...l,id:u.id}}catch{throw new Error("Failed to create match")}}async joinRoom(n,t){try{const r=await this.getMatchByInviteCode(n);if(!r)throw new Error("Room not found");return r.entryFee>0&&t.id.startsWith("guest_"),await this.joinMatch({matchId:r.id,userId:t.id,userName:t.name,userAvatar:t.avatar})}catch(r){throw r}}async makeBid29(n,t,r,e,s){const i={...e.bids};let a=e.highestBid,d=e.phase,l=e.bidWinner,u=e.currentPlayer,f=e.bainPhase,c=e.currentBidder;const p=e.passedPlayers||[];if(p.includes(t))throw new Error("Player has already passed!");if(r==="pass"){if(i[t]=0,p.includes(t)||p.push(t),a&&t===a.playerId){let o=-1,b=null;s.forEach(A=>{const D=i[A.userId]||0;D>o?(o=D,b=A.userId):D===o&&o>0&&(b=A.userId)}),o>0?a={playerId:b,amount:o}:a=null}}else{if(r<16)throw new Error("Minimum bid is 16");if(r>28)throw new Error("Maximum bid is 28");if(a&&r<a.amount)throw new Error(`Bid must be at least ${a.amount} `);if(a&&r===a.amount){const o=a.playerId;c=s.findIndex(b=>b.userId===o),i[t]=r,await w(m(this.matchesCollection,n),{gameState:{...e,bids:i,currentBidder:c,passedPlayers:p,turnStartedAt:y()}});return}if(i[t]=r,a={playerId:t,amount:r},r===28){d="playing",l=t,u=s.findIndex(o=>o.userId===t),f="double_chance",await w(m(this.matchesCollection,n),{gameState:{...e,bids:i,highestBid:a,phase:d,bidWinner:l,currentPlayer:u,currentBidder:c,bainPhase:f,turnStartedAt:y()}});return}}const C=s.filter(o=>i[o.userId]!==0);if(C.length<=1&&a)d="playing",l=a.playerId,u=s.findIndex(o=>o.userId===a?.playerId),f="double_chance";else if(C.length===0&&Object.keys(i).length>=s.length){d="playing";const o=e.dealerIndex||0;l=s[o].userId,u=o,a={playerId:s[o].userId,amount:16},f="double_chance"}else{let o=c,b=0;do o=(o+3)%s.length,b++;while((i[s[o].userId]===0||p.includes(s[o].userId))&&b<s.length);c=o}await w(m(this.matchesCollection,n),{gameState:{...e,bids:i,highestBid:a,phase:d,bidWinner:l,currentPlayer:u,currentBidder:c,bainPhase:f,passedPlayers:p,turnStartedAt:y()}})}async joinMatch(n){try{const t=m(this.matchesCollection,n.matchId),r=await S(t);if(!r.exists())throw new Error("Match not found");const e={id:r.id,...r.data()};if(e.status!=="waiting")throw new Error("Match is no longer accepting players");if(e.players.length>=e.maxPlayers)throw new Error("Match is full");if(e.players.some(f=>f.userId===n.userId))throw new Error("Already joined this match");const s={userId:n.userId,userName:n.userName,userAvatar:n.userAvatar,joinedAt:new Date().toISOString(),coinsLocked:e.entryFee,role:"participant"},i=[...e.players,s],a=e.entryFee*i.length,d=a*(e.platformFee/100),l=a-d,u=i.length===e.maxPlayers?"locked":"waiting";return await w(t,{players:i,prizePool:a,platformFeeAmount:d,winnerPrize:l,status:u,...u==="locked"&&{startsAt:y()}}),{...e,players:i,prizePool:a,platformFeeAmount:d,winnerPrize:l,status:u,...u==="locked"&&{startsAt:new Date().toISOString()}}}catch(t){throw t instanceof Error?t:new Error("Failed to join match")}}async getMatch(n){try{const t=await S(m(this.matchesCollection,n));return t.exists()?{id:t.id,...t.data()}:null}catch{return null}}async getPublicLobbies(n){try{let t=F(this.matchesCollection,x("visibility","==","public"),x("status","==","waiting"),N("createdAt","desc"),H(20));return n&&(t=F(this.matchesCollection,x("visibility","==","public"),x("status","==","waiting"),x("gameId","==",n),N("createdAt","desc"),H(20))),(await q(t)).docs.map(e=>({id:e.id,...e.data()}))}catch{return[]}}listenToMatch(n,t){const r=m(this.matchesCollection,n);return J(r,e=>{if(!e.exists()){t(null);return}t({id:e.id,...e.data()})},e=>{t(null)})}async submitResult(n){try{const t=m(this.matchesCollection,n.matchId);await w(t,{status:"completed",winnerId:n.winnerId,winnerName:n.winnerName,completedAt:y()})}catch{throw new Error("Failed to submit match result")}}async cancelMatch(n,t){try{const r=await this.getMatch(n);if(!r)throw new Error("Match not found");if(r.creatorId!==t)throw new Error("Only creator can cancel");if(r.status!=="waiting")throw new Error("Cannot cancel started match");const e=m(this.matchesCollection,n);await w(e,{status:"cancelled"})}catch(r){throw r instanceof Error?r:new Error("Failed to cancel match")}}async getUserMatches(n){try{const t=F(this.matchesCollection,x("status","in",["waiting","locked","in_progress"]),N("createdAt","desc"));return(await q(t)).docs.map(s=>({id:s.id,...s.data()})).filter(s=>s.players.some(i=>i.userId===n))}catch{return[]}}async getMatchByInviteCode(n){try{const t=F(this.matchesCollection,x("inviteCode","==",n.toUpperCase()),x("status","in",["waiting","locked"]),H(1)),r=await q(t);return r.empty?null:{id:r.docs[0].id,...r.docs[0].data()}}catch{return null}}generateInviteCode(){return Math.random().toString(36).substring(2,8).toUpperCase()}async addBotToMatch(n){try{const t=m(this.matchesCollection,n),r=await S(t);if(!r.exists())throw new Error("Match not found");const e=r.data();if(e.players.length>=e.maxPlayers)throw new Error("Match is full");const s=e.players.filter(l=>l.isBot).length+1,i={userId:`bot - ${Date.now()} `,userName:`Bot Player ${s} `,userAvatar:`https://api.dicebear.com/7.x/bottts/svg?seed=${Date.now()}`,joinedAt:new Date().toISOString(),coinsLocked:0,role:"participant",isBot:!0},a=[...e.players,i],d=a.length===e.maxPlayers?"locked":e.status;await w(t,{players:a,status:d,...d==="locked"&&{startsAt:y()}})}catch{throw new Error("Failed to add bot")}}async removeBotFromMatch(n,t){try{const r=m(this.matchesCollection,n),e=await S(r);if(!e.exists())throw new Error("Match not found");const s=e.data(),i=s.players.filter(d=>d.userId!==t),a=i.length<s.maxPlayers?"waiting":s.status;await w(r,{players:i,status:a})}catch{throw new Error("Failed to remove bot")}}async playCard29(n,t,r,e,s){const i=s.findIndex(h=>h.userId===t);if(e.currentPlayer!==i||e.currentTrick.some(h=>h.playerId===t))return;if(e.currentTrick&&e.currentTrick.length>0){const h=e.currentTrick[0].card.suit;if(e.hands[t].some(I=>I.suit===h)&&r.suit!==h)throw new Error("Must follow suit!")}const a={...e.hands};a[t]=a[t].filter(h=>h.suit!==r.suit||h.rank!==r.rank);const d={playerId:t,card:r,playerName:s.find(h=>h.userId===t)?.userName||"Player"},l=[...e.currentTrick,d],u=[...e.lastTrickCards||[],d].slice(-4);let f=(e.currentPlayer-1+s.length)%s.length,c=e.tricks,p={...e.scores},C=l,o=e.round,b=e.trumpSuit,A=e.phase;if(l.length===s.length){const h=this.determineTrickWinner(l,e.trumpRevealed?b:null,e);await w(m(this.matchesCollection,n),{"gameState.hands":a,"gameState.currentTrick":l,"gameState.lastTrickCards":u,"gameState.lastMoveTime":new Date().toISOString(),"gameState.lastWinnerId":h}),await new Promise(I=>setTimeout(I,2e3));let K=l.reduce((I,B)=>I+this.getCardValue(B.card.rank),0);p[h]=(p[h]||0)+K;const L=Object.keys(c).length;if(c={...c,[L]:l},C=[],f=s.findIndex(I=>I.userId===h),e.singleHandMode){const B=1*(e.isRedoubled?4:e.isDoubled?2:1),T=s.findIndex(W=>W.userId===e.bidWinner)%2,M=s.findIndex(W=>W.userId===h)%2,E=T===M?B:-B,P=e.gamePoints?{...e.gamePoints}:{team1:0,team2:0};T===0?P.team1=(P.team1||0)+E:P.team2=(P.team2||0)+E,await w(m(this.matchesCollection,n),{status:"completed",winnerId:h,"gameState.gamePoints":P,"gameState.phase":"completed"});return}if(Object.keys(c).length===8){const I=[s[0].userId,s[2].userId],B=[s[1].userId,s[3].userId],T=I.reduce((k,j)=>k+(p[j]||0),0),M=B.reduce((k,j)=>k+(p[j]||0),0),Q=(e.highestBid?.amount||16)+(e.bidAdjustment||0),E=e.bidWinner,P=I.includes(E)?1:2,O=(P===1?T:M)>=Q;let v=1*(e.isRedoubled?4:e.isDoubled?2:1);const R=!e.trumpRevealed;R&&(v=0);const g=e.gamePoints?{...e.gamePoints}:{team1:0,team2:0};R||(O?P===1?g.team1=(g.team1||0)+v:g.team2=(g.team2||0)+v:P===1?g.team1=(g.team1||0)-v:g.team2=(g.team2||0)-v);const _=g.team1||0,z=g.team2||0;if(Math.abs(_)>=6||Math.abs(z)>=6){const k=Math.abs(_)>=6?1:2;e.setWinner={team:k},e.showSetPopup=!0}else{const k=O?P:P===1?2:1;e.roundWinner={team:R?0:k,points:k===1?T:M,bidWon:O,isDraw:R},e.showRoundPopup=!0}e.gamePoints=g}}const D={...e,hands:a,currentTrick:C,tricks:c,currentPlayer:f,scores:p,round:o,phase:A,trumpSuit:b,lastTrickCards:u,turnStartedAt:y(),lastMoveTime:new Date().toISOString()};await w(m(this.matchesCollection,n),{gameState:D})}async selectTrump29(n,t,r,e,s){if(e.bidWinner!==t)throw new Error("Only the bid winner can select trump");const i={...e.hands},a=e.remainingDeck||[];if(!e.secondDealComplete&&a.length>=16){const u=((e.dealerIndex||0)+3)%4;s.forEach((f,c)=>{const p=(u-c+4)%4,C=s[p],o=a.slice(c*4,(c+1)*4);i[C.userId]=[...i[C.userId]||[],...o]})}const d={...e,trumpSuit:r,hands:i,secondDealComplete:!0,remainingDeck:[],turnStartedAt:y(),lastMoveTime:new Date().toISOString()};await w(m(this.matchesCollection,n),{gameState:d})}async revealTrump29(n,t){if(!t.trumpSuit)return;const r={...t,trumpRevealed:!0,turnStartedAt:y(),lastMoveTime:new Date().toISOString()};await w(m(this.matchesCollection,n),{gameState:r})}async declarePair29(n,t,r,e){if(!r.trumpRevealed||!r.trumpSuit)throw new Error("Trump must be revealed first");const s=r.hands[t]||[],i=s.some(c=>c.suit===r.trumpSuit&&c.rank==="K"),a=s.some(c=>c.suit===r.trumpSuit&&c.rank==="Q");if(!i||!a)throw new Error("You don't have the Pair (K & Q of Trump)");const d=e.findIndex(c=>c.userId===r.bidWinner)%2,l=e.findIndex(c=>c.userId===t)%2,u=d===l?-4:4,f={...r,bidAdjustment:(r.bidAdjustment||0)+u,pairDeclaredBy:t,turnStartedAt:y()};await w(m(this.matchesCollection,n),{gameState:f})}async dismissRoundPopup(n,t){const r=((t.dealerIndex||0)+3)%4,e=(r+3)%4,s={...t,round:(t.round||1)+1,dealerIndex:r,currentBidder:e,currentPlayer:e,currentTrick:[],tricks:{},scores:{},trumpSuit:null,trumpRevealed:!1,highestBid:null,bidWinner:null,bids:{},passedPlayers:[],secondDealComplete:!1,phase:"bidding",hands:{},roundWinner:null,showRoundPopup:!1,bidAdjustment:0,pairDeclaredBy:null,pairShown:!1,remainingDeck:[],lastTrickCards:[],turnStartedAt:y()};await w(m(this.matchesCollection,n),{gameState:s})}async dismissSetPopup(n,t){const r={...t,round:1,gamePoints:{team1:0,team2:0},currentTrick:[],tricks:{},scores:{},trumpSuit:null,trumpRevealed:!1,highestBid:null,bidWinner:null,bids:{},passedPlayers:[],secondDealComplete:!1,phase:"bidding",hands:{},roundWinner:null,showRoundPopup:!1,setWinner:null,showSetPopup:!1,bidAdjustment:0,pairDeclaredBy:null,remainingDeck:[],turnStartedAt:y(),currentBidder:0,currentPlayer:0};await w(m(this.matchesCollection,n),{gameState:r})}determineTrickWinner(n,t,r){const e={J:8,9:7,A:6,10:5,K:4,Q:3,8:2,7:1};if(r?.singleHandMode){let i=n[0];return n.forEach(a=>{e[a.card.rank]>e[i.card.rank]&&(i=a)}),i.playerId}let s=n[0];return n.forEach(i=>{(i.card.suit===t&&s.card.suit!==t||i.card.suit===s.card.suit&&e[i.card.rank]>e[s.card.rank])&&(s=i)}),s.playerId}getCardValue(n){return{J:3,9:2,A:1,10:1,K:0,Q:0,8:0,7:0}[n]||0}}const te=new Y;export{te as m};
